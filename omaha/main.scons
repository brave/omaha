#!/usr/bin/python2.4
#
# Copyright 2009-2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ========================================================================


# This main.scons file is the root description of the build specified in this
# directory and those under it. Individual components and the source files
# used to build them are described in subsidiary files called 'build.scons'.
#
# To build this project change the current directory to googleclient/Omaha.
# Then run hammer.bat
#
# A number of command line options can be specified. For a full list, use the
# -h and -H command options.
#
# Some useful options include:
#   -h   :   Prints a list of which modules and build variants are available
#            in this project.
#   -H   :   Print SCons specific help. SCons is a build tool which this
#            project uses in tandem with the Software Construction Toolkit
#            to build.
#   -c   :   Clean the project. I.e. delete all build output.
#   -j3  :   Run up to 3 build steps at once.
#
# Some useful build targets include:
#    all_programs    :   Build all programs generated by this project.
#    all_libraries   :   Build all libraries generated by this project.
#    all_tests       :   Build all tests generated by this project.
#    run_all_tests   :   Build and run all tests generated by this project.
#
# Some examples:
#   Build all programs and libraries in debug mode:
#     hammer
#   Build and run all tests in debug mode on windows:
#     hammer MODE=dbg-win run_all_tests
#   Build arbitrary library in the default mode:
#     hammer <library name>

import copy
import os
import sys

import omaha_version_utils

# Build the "Google Update", the Google-specific version of Omaha.
# TODO(omaha): Set based on an environment variable and/or Hammer arg.
_is_google_update_build = False

#
# Begin vendor-specific constants.
#
# These values must be changed when customizing open source Omaha.
# You may also wish to replace the language-neutral constants in the individual
# *generated_resources_*.rc files with localized strings.
_FULL_COMPANY_NAME = 'HerondLabs Inc.'
_SHORT_COMPANY_NAME = 'HerondLabs'
_PATH_COMPANY_NAME = 'HerondLabs'
_PRODUCT_NAME = 'Update'
_COMPANY_DOMAIN_BASE = 'herondlabs'
_COMPANY_DOMAIN = _COMPANY_DOMAIN_BASE + '.org'
_MAIN_EXE_BASE_NAME = 'HerondUpdate'
# TODO(omaha): Use this throughout the build files where goopdate and
# goopdateres are referenced.
_MAIN_DLL_BASE_NAME = 'goopdate'
# "Google LLC" must not be removed from the copyright string. This literal also
# appears as LegalCopyright in the VERSIONINFO section of .rc files.
# TODO(omaha): Use this variable in .wxs files, etc.
_OMAHA_COPYRIGHT_STRING_ENGLISH = ''


# TODO(omaha): Allow open source Omaha to be built without the Recovery MSI,
# which requires an extra certificate file and is unlikely to be used, or
# ClickOnce, which requires specifying a certificate hash. Disabling Recovery
# by default also means the open source build will work by default without
# having to check in SaveArguments.exe to SVN every 100 days.
# TODO(omaha3): Allow open source Omaha to be built without support for
# Omaha 2's COM APIs.

#
# End vendor-specific constants.
#

# Reads the value of OMAHA_MSC_VER to determine which compiler/toolchain to use.
# The set of expected values are in omaha_version_utils.
# Defaults to VC160 (Visual Studio 2019) if the environment variable is not
# specified.
_msc_ver = int(os.getenv('OMAHA_MSC_VER', "1920"))

_sdk_dir = os.getenv('WindowsSdkDir', os.getenv('OMAHA_PLATFORM_SDK_DIR'))
if (_sdk_dir is None):
    _sdk_dir = ('$GOOGLE3/third_party/%s/files' %
   { omaha_version_utils.VC160:'windows_sdk/windows_sdk_10',
     omaha_version_utils.VC150:'windows_sdk/windows_sdk_10',
     omaha_version_utils.VC140:'windows_sdk/windows_sdk_10',
     omaha_version_utils.VC120:'windows_sdk_8_1',
     omaha_version_utils.VC100:'platformsdk_vc_10_0',
     omaha_version_utils.VC80:'platformsdk/v6_1' }[_msc_ver])

_sdk_version = os.getenv('OMAHA_WINDOWS_SDK_10_0_VERSION', None)
_wtl_dir = os.getenv('OMAHA_WTL_DIR', '$GOOGLE3/third_party/wtl/files')
_signtool_path = ('python "$MAIN_DIR/tools/retry.py" 10 5 \"%s/%s\"' %
                  (os.getenv('OMAHA_SIGNTOOL_SDK_DIR'), 'signtool.exe'))

# Windows is the only environment we bulid for, so create a specialized base
# environment for Windows.
win_env = Environment(
    # For internal builds only, it is a good idea to have set before the
    # 'component_setup' tool is used even though we add the SDK directories to
    # the appropriate environment variables manually below.
    PLATFORM_SDK_DIR = _sdk_dir,
    WINDOWS_SDK_10_0_VERSION=_sdk_version,
    tools=[
        'component_setup',
        'target_platform_windows',
        { omaha_version_utils.VC160:'windows_vc16_0_host64_x86',
          omaha_version_utils.VC150:'windows_vc15_0_host64_x86',
          omaha_version_utils.VC140:'windows_vc14_0',
          omaha_version_utils.VC120:'windows_vc12_0',
          omaha_version_utils.VC100:'windows_vc10_0',
          omaha_version_utils.VC80:'target_platform_windows' }[_msc_ver],
        'masm',         # Use 'masm' to override the 'as' tool currently
                        # used by default in 'target_platform_windows'
        { omaha_version_utils.VC160:'atlmfc_vc16_0',
          omaha_version_utils.VC150:'atlmfc_vc15_0',
          omaha_version_utils.VC140:'atlmfc_vc14_0',
          omaha_version_utils.VC120:'atlmfc_vc12_0',
          omaha_version_utils.VC100:'atlmfc_vc10_0',
          omaha_version_utils.VC80:'atlmfc_vc80' }[_msc_ver],
        'code_signing',
        'component_targets_msvs',
        'omaha_builders',
    ],
    msc_ver = _msc_ver,

    # Visual Studio 2008 does not ship the sign tool. Use the sign tool from
    # the Platform SDK. This must come after the 'code_signing' tool is used.
    # Remove this if http://code.google.com/p/swtoolkit/issues/detail?id=16 is
    # fixed.
    SIGNTOOL = _signtool_path,
)

win_env['ENV']['GOROOT'] = os.getenv('GOROOT',
                                     win_env.subst('$MAIN_DIR') +
                                     '\\..\\third_party\\go\\files')
win_env['ENV']['LocalAppData'] = os.getenv('LocalAppData')

# Append paths for supporting tools such as uuidgen.exe.
win_env.AppendENVPath('PATH', (os.environ['WindowsSdkVerBinPath'] + '\\x86\\'))

if os.getenv('n3fips_password'):
    # Forward this env. var, which is used for CloudHSM code signing.
    win_env['ENV']['n3fips_password'] = os.getenv('n3fips_password')

# Remove this value because it conflicts with a #define
# in shlwapi.h in the Vista SDK
win_env.FilterOut(CPPDEFINES = ['OS_WINDOWS=OS_WINDOWS'])

# We pre-generate our own manifests, so make sure hammer does not generate
# default ones for us
del win_env['MANIFEST_FILE']

# Hack to work around bug in Hammer (http://b/1585388).
# TODO(Omaha): Remove when bug is fixed.
if win_env['ENV'].has_key('SYSTEMROOT'):
  if win_env['ENV'].has_key('SystemRoot'):
    del win_env['ENV']['SYSTEMROOT']
    del os.environ['SYSTEMROOT']

# Work around http://code.google.com/p/swtoolkit/issues/detail?id=10.
win_env['COMPONENT_TEST_SUBSYSTEM_WINDOWS'] = 1

# Declare command line options relating to code signing
# authenticode_file and authenticode_password are used by the normal signing
# tool.
# authenticode_file and authenticode_password are only used if !build_server.
AddOption(
    '--authenticode_file',
    action='store',
    nargs=1,
    type='string',
    default=None
)

default_cert_password = 'test'
AddOption(
    '--authenticode_password',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--authenticode_hash',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--sha1_authenticode_hash',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--sha2_authenticode_hash',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--sha1_authenticode_file',
    action='store',
    nargs=1,
    type='string',
    default=None
)

default_sha1_cert_password = '888'
AddOption(
    '--sha1_authenticode_password',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--sha2_authenticode_file',
    action='store',
    nargs=1,
    type='string',
    default=None
)

default_sha2_cert_password = '888'
AddOption(
    '--sha2_authenticode_password',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--sha1_csp',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--sha2_csp',
    action='store',
    nargs=1,
    type='string',
    default=None
)

# Declare option for specifying path to new official build files
AddOption(
    '--official_build_path',
    action='store',
    nargs=1,
    type='string',
    default=None
)

# Declare option for specifying the set of official app installers to build.
# The value describes the name of the directory containing the official
# installer manifests and definitions.
AddOption(
    '--official_installer_app',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--official_installer_file',
    action='store',
    nargs=1,
    type='string',
    default=None
)

AddOption(
    '--build_number',
    action='store',
    nargs=1,
    type='string',
    default=''
)

AddOption(
    '--standalone_installers_dir',
    action='store',
    nargs=1,
    type='string',
    default='$MAIN_DIR/standalone'
)

# Declare various boolean states.
DeclareBit('is_google_update_build', 'True if building Google Update')
DeclareBit('official_installers', 'Building using checked-in binaries')
DeclareBit('build_server', 'Running on the build server')
DeclareBit('build_two_versions', 'Build second version for self-update testing')
DeclareBit('build_three_versions', 'Build a second and a third version for'
           'self-update testing')
DeclareBit('test_certificate', 'Files will be signed with the test certificate')
DeclareBit('bin', 'Building from pre-built binaries')
DeclareBit('min', 'Building minimal set of projects')
DeclareBit('all', 'Building all Projects')
DeclareBit('msvs', 'Building Visual Studio solution files')
DeclareBit('no-tests', 'Do not build the unit tests')
DeclareBit('x64', 'Build 64 bit code')
DeclareBit('analysis', 'Turns on static analysis')
DeclareBit('suppress_light_validation', 'Suppress WiX Linker ICE validation')
DeclareBit('has_device_management',
           'True if including cloud-based device management')
DeclareBit('verify_payload_authenticode_signature',
           'Whether to verify the Authenticode signature of payloads')
DeclareBit('use_authenticode_machine_store',
           'Use the machine store, instead of the user store, of certificates')

# Build official installers if --official_installers is on the command line.
win_env.SetBitFromOption('official_installers', False)

# Build as a build server if --build_server is on the command line.
win_env.SetBitFromOption('build_server', False)

# Build two versions if --build_two_versions is on the command line.
win_env.SetBitFromOption('build_two_versions', False)

# Build three versions if --build_three_versions is on the command line.
win_env.SetBitFromOption('build_three_versions', False)

# Store new versions of pre-built binaries if --bin is on the command line.
win_env.SetBitFromOption('bin', False)

# Build minimal set of libs if --min is on the command line.
win_env.SetBitFromOption('min', False)

# Build all libs if --all is on the command line.
win_env.SetBitFromOption('all', False)

# Build Visual Studio solution files if --msvs is on the command line.
win_env.SetBitFromOption('msvs', False)

# Do not build the unit tests if the bit is set.
win_env.SetBitFromOption('no-tests', False)

# Set if this is a Google build, otherwise, it is an open source build.
if _is_google_update_build:
  win_env.SetBits('is_google_update_build')
  # Ordinarily, presence of device management integration is only for Google
  # Update builds. It can be configured independently in case a forker wishes
  # to provide their own device management server.
  win_env.SetBits('has_device_management')

if win_env.Bit('build_server'):
  win_env.SetBits('all')

# 'all' overrides 'min'.
if win_env.Bit('all'):
  win_env.ClearBits('min')

# 'build_three_versions' overrides 'build_two_versions'.
if win_env.Bit('build_three_versions'):
  win_env.ClearBits('build_two_versions')

# Allow use of command-line-specified certificates to sign with, but
# only if we're not on the build server.
if not win_env.Bit('build_server'):
  _authenticode_hash = GetOption('authenticode_hash')
  _authenticode_file = GetOption('authenticode_file')
  _authenticode_password = GetOption('authenticode_password')
  if not _authenticode_hash and not _authenticode_file:
    assert not _authenticode_password
    win_env.SetBits('test_certificate')
    _authenticode_file = '$MAIN_DIR/data/OmahaTestCert.pfx'
    _authenticode_password = default_cert_password

  _sha1_authenticode_hash = GetOption('sha1_authenticode_hash')
  _sha2_authenticode_hash = GetOption('sha2_authenticode_hash')
  _sha1_authenticode_file = GetOption('sha1_authenticode_file')
  _sha2_authenticode_file = GetOption('sha2_authenticode_file')
  _sha1_authenticode_password = GetOption('sha1_authenticode_password')
  _sha2_authenticode_password = GetOption('sha2_authenticode_password')
  _sha1_csp = GetOption('sha1_csp')
  _sha2_csp = GetOption('sha2_csp')
  if not _sha1_authenticode_hash and not _sha2_authenticode_hash \
    and not _sha1_authenticode_file and not _sha2_authenticode_file:
    assert not _sha1_authenticode_password and not _sha2_authenticode_password
    _sha1_authenticode_file = '$MAIN_DIR/data/Sha1OmahaTestCert.pfx'
    _sha2_authenticode_file = '$MAIN_DIR/data/Sha2OmahaTestCert.pfx'
    _sha1_authenticode_password = default_sha1_cert_password
    _sha2_authenticode_password = default_sha2_cert_password

  win_env.Replace(
    CERTIFICATE_HASH=_authenticode_hash,
    CERTIFICATE_PASSWORD=_authenticode_password,
    CERTIFICATE_PATH=_authenticode_file,
    SHA1_CERTIFICATE_HASH=_sha1_authenticode_hash,
    SHA2_CERTIFICATE_HASH=_sha2_authenticode_hash,
    SHA1_CERTIFICATE_ISSUER='',
    SHA2_CERTIFICATE_ISSUER='',
    SHA1_CERTIFICATE_PASSWORD=_sha1_authenticode_password,
    SHA2_CERTIFICATE_PASSWORD=_sha2_authenticode_password,
    SHA1_CERTIFICATE_PATH=_sha1_authenticode_file,
    SHA2_CERTIFICATE_PATH=_sha2_authenticode_file,
    SHA1_CSP=_sha1_csp,
    SHA2_CSP=_sha2_csp
  )

# Build the 64 bit version of the code.
win_env.SetBitFromOption('x64', False)

# Turns on static analysis.
win_env.SetBitFromOption('analysis', False)

# Supresses WiX Linker ICE validation. Useful when building with a
# non-interactive account or a non-Admin account: http://goo.gl/UyDzeP.
win_env.SetBitFromOption('suppress_light_validation', False)

# Whether the Authenticode signature of update payloads should be verified.
win_env.SetBitFromOption('verify_payload_authenticode_signature', False)

# Whether to use the machine store instead of the user store for certificates.
win_env.SetBitFromOption('use_authenticode_machine_store', False)

#
# Set up version info.
#
# If specified on the command line, either two or three successive versions
# of the build targets could be produced by the build script. Such versions
# are useful for creating A/B experiments to test the update paths from
# current version to future versions and assess the quality of releases.
omaha_version_info = omaha_version_utils.OmahaVersionInfo('VERSION')
omaha_versions_info = [omaha_version_info]
if win_env.Bit('build_two_versions'):
  omaha_test_version_info = copy.deepcopy(omaha_version_info)
  omaha_test_version_info.MakeTestVersion(delta=1, prefix='TEST_')
  omaha_versions_info.append(omaha_test_version_info)
elif win_env.Bit('build_three_versions'):
  omaha_test_version_info = copy.deepcopy(omaha_version_info)
  omaha_test_version_info.MakeTestVersion(delta=1, prefix='TEST_')
  omaha_versions_info.append(omaha_test_version_info)
  omaha_test_2_version_info = copy.deepcopy(omaha_version_info)
  omaha_test_2_version_info.MakeTestVersion(delta=2, prefix='TEST2_')
  omaha_versions_info.append(omaha_test_2_version_info)

# Print the version(s) being built.
print 'Building versions: %s' % ', '.join(
    [version_info.GetVersionString() for version_info in omaha_versions_info])

build_number = GetOption('build_number')
if build_number:
  print 'Build number: %s' % build_number

win_env['standalone_installers_dir'] = GetOption('standalone_installers_dir')

win_env['omaha_versions_info'] = omaha_versions_info

if _is_google_update_build:
    win_env.Append(
        CPPDEFINES = ['GOOGLE_UPDATE_BUILD'],
        RCFLAGS = ['/DGOOGLE_UPDATE_BUILD=1'],
    )

if win_env.Bit('has_device_management'):
    win_env.Append(
        CPPDEFINES = ['HAS_DEVICE_MANAGEMENT'],
    )
    if _is_google_update_build:
        # Google Update includes integration specific to Google Chrome, which
        # should not be present in other forks of Omaha.
        win_env.Append(
            CPPDEFINES = ['HAS_LEGACY_DM_CLIENT'],
        )

if win_env.Bit('verify_payload_authenticode_signature'):
    win_env.Append(
        CPPDEFINES = ['VERIFY_PAYLOAD_AUTHENTICODE_SIGNATURE'],
    )

# Make sure python.exe can be located.
win_env.AppendENVPath('PATH', os.environ['OMAHA_PYTHON_DIR'])

# VS2013 does not ship a debug version of the ATL static library. Therefore,
# only one version of the library is required.
win_env['atls_libs'] = (['atls'], ['atlsd'])
if _msc_ver >= omaha_version_utils.VC120:
    win_env['atls_libs'] = (['atls'], ['atls'])

# VS2015 has a set of new libraries as part of the universal CRT.
win_env['crt_libs'] = (['libcmt', 'libcpmt'], ['libcmtd', 'libcpmtd'])
if _msc_ver >= omaha_version_utils.VC140:
    win_env['crt_libs'] = (
        ['libconcrt', 'libcmt', 'libcpmt', 'libvcruntime', 'libucrt'],
        ['libconcrtd', 'libcmtd', 'libcpmtd', 'libvcruntimed', 'libucrtd'])

win_env.FilterOut(CCFLAGS=['/W3'])

win_env.AppendUnique(
    CCFLAGS = [
        '/arch:IA32',
        ('', '/analyze:WX-')[win_env.Bit('analysis')],
        '/c',
        '/D_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES=1',
        '/D_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES=1',
        '/D_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT=1',
        '/D_HAS_EXCEPTIONS=0',
        '/D_USING_V110_SDK71_',
        '/DCOMPILER_MSVC',
        '/DSTL_MSVC',
        '/GR-',
        '/GS',
        '/nologo',
        '/permissive-',
        '/std:c++17',
        '/W4',
        '/Wall',
        '/WX',            # warnings as errors
        '/Zo',            # better debugging support for optimized code

        #
        # Disable the following level 4 warnings below.
        #
        '/wd4061',  # enumerate is not explicitly handled by a case label
        '/wd4127',  # conditional expression is constant
        '/wd4189',  # local variable is initialized but not referenced

        #
        # Disable the pedantic warnings below.
        #
        '/wd4091',  # 'typedef': ignored on left of when no variable is declared
        '/wd4191',  # unsafe conversion from 'type of expression' to
                    # 'type required'
        '/wd4217',  # member template functions cannot be used for
                    # copy-assignment...
        '/wd4365',  # conversion from 'type_1' to 'type_2',
                    # signed/unsigned mismatch
        '/wd4371',  # layout of class may have changed from a previous version
                    # of the compiler due to better packing of member
        '/wd4505',  # unreferenced local function has been removed
        '/wd4510',  # default constructor could not be generated
        '/wd4512',  # assignment operator could not be generated
        '/wd4514',  # unreferenced inline function has been removed
        '/wd4548',  # expression before comma has no effect
        '/wd4555',  # expression has no effect
        '/wd4577',  # 'noexcept' used with no exception handling mode specified;
                    # termination on exception is not guaranteed.
        '/wd4605',  # '...' specified on current command line, but was not
                    # specified when precompiled header was built.
        '/wd4610',  # struct can never be instantiated
        '/wd4619',  # there is no warning number 'number'
        '/wd4623',  # default constructor could not be generated...
        '/wd4625',  # copy constructor could not be generated...
        '/wd4626',  # assignment operator could not be generated...
        '/wd4668',  # not defined as a preprocessor macro, replacing with '0'.
        '/wd4710',  # function not inlined
        '/wd4711',  # function 'function' selected for inline expansion
        '/wd4738',  # storing 32-bit float result in memory...
        '/wd4755',  # Conversion rules for arithmetic operations in the
                    # comparison at mean that one branch cannot be executed
                    # in an inlined function.
        '/wd4768',  # __declspec attributes before linkage specification are
                    # ignored
        '/wd4774',  # format string expected in argument is not a string literal
        '/wd4777',  # format string 'requires an argument of type...
        '/wd4820',  # bytes padding added after construct 'member_name'
        '/wd4840',  # non-portable use of class as an arg to a variadic function
        '/wd4986',  # exception specification doesn't match previous declaration
        '/wd4987',  # nonstandard extension used: 'throw (...)
        '/wd4995',  # name was marked as #pragma deprecated
        '/wd4996',  # 'function': was declared deprecated
        '/wd5032',  # detected #pragma warning(push) with no corresponding
                    # #pragma warning(pop) - due to a WinSDK bug in winioctl.h.
        '/wd5038',  # data member '' will be initialized after data member ''
        '/wd5041',  # out-of-line definition for constexpr static data member is
                    # not needed and is deprecated in C++17'.
        '/wd5042',  # function declarations at block scope cannot be specified
                    # 'inline' in standard C++
        '/wd5045',  # Compiler will insert Spectre mitigation for memory load
        '/wd5054',  # operator '*': deprecated between enumerations of different
                    # types
        '/wd5204',  # class has virtual functions, but its trivial destructor
                    # is not virtual; instances of objects derived from this
                    # class may not be destructed correctly
        '/wd5205',  # delete of an abstract class ... that has a non-virtual
                    # destructor results in undefined behavior
        '/wd5214',  # applying '++' to an operand with a volatile qualified type
                    # is deprecated in C++20'
        '/wd5219',  # implicit conversion from 'size_t' to 'const float',
                    # possible loss of data
        '/wd5220',  # a non-static data member with a volatile qualified type no
                    # longer implies that compiler generated copy/move
                    # constructors and copy/move assignment operators are non
                    # trivial
        '/wd5245',  # 'function': unreferenced function with internal linkage
                    # has been removed
        '/wd5246',  # 'member': the initialization of a subobject should be
                    # wrapped in braces
        #
        # Disable static analysis warnings.
        #
        '/wd28159', # Consider using 'GetTickCount64' instead of 'GetTickCount'.
        '/wd28204', # Inconsistent SAL annotations.
        '/wd28251', # Inconsistent SAL annotations.
    ],

    CPPPATH = [
        _wtl_dir +'/include',
        '$GOOGLE3',
        '$GOOGLECLIENT',
        '$MAIN_DIR',
        '$MAIN_DIR/third_party/chrome/files/src',
        '$OBJ_ROOT',  # Contains .h files generated by the midl compiler.
        '$GOOGLE3/third_party/breakpad/src',
        '$GOOGLE3/third_party/googletest/googlemock/include',
        '$GOOGLE3/third_party/googletest/googletest/include',
        '$GOOGLE3/third_party/libzip/lib',
    ],

    CPPDEFINES = [
        '_ATL_ALL_WARNINGS',
        '_ATL_CSTRING_EXPLICIT_CONSTRUCTORS',
        '_ATL_CSTRING_NO_CRT',
        '_ATL_NO_ACLAPI',
        '_ATL_NO_DEFAULT_LIBS',
        '_ATL_NO_EXCEPTIONS',
        '_ATL_NO_GLOBAL_SOCKET_STARTUP',
        '_ATL_NO_PERF_SUPPORT',
        '_ATL_NO_TRACK_HEAP',
        '_ATL_STATIC_REGISTRY',
        '_ATL_XP_TARGETING',
        '_SECURE_ATL=1',
        '_WTL_NO_CSTRING',  # WTL uses ATL CString instead.

        'ARCH_CPU_X86_FAMILY',  # For Chromium code.
        'LOGGING',   # Logging is enabled in all modes for diagnostics purposes.

        # For the CRX Verifier protocol buffers code.
        'GOOGLE_PROTOBUF_NO_RTTI',
        'GOOGLE_PROTOBUF_SUPPORT_WINDOWS_XP',

        'NOMINMAX',
        'PSAPI_VERSION=1',
        '_UNICODE',
        'UNICODE',
        'SECURITY_WIN32',
        'STRICT',
        '_WINDOWS',
        'WIN32',
        'WIN32_LEAN_AND_MEAN',
        'WINVER=0x0601',  # Windows 7.
        'ZIP_STATIC',

        'FULL_COMPANY_NAME_ANSI=\\"%s\\"' % _FULL_COMPANY_NAME,
        'SHORT_COMPANY_NAME_ANSI=\\"%s\\"' % _SHORT_COMPANY_NAME,
        'PATH_COMPANY_NAME_ANSI=\\"%s\\"' % _PATH_COMPANY_NAME,
        'PRODUCT_NAME_ANSI=\\"%s\\"' % _PRODUCT_NAME,
        'COMPANY_DOMAIN_BASE_ANSI=\\"%s\\"' % _COMPANY_DOMAIN_BASE,
        'COMPANY_DOMAIN_ANSI=\\"%s\\"' % _COMPANY_DOMAIN,
        'OMAHA_APP_NAME_ANSI=\\"%s %s\\"' % (
            _SHORT_COMPANY_NAME, _PRODUCT_NAME),
        'MAIN_EXE_BASE_NAME_ANSI=\\"%s\\"' % _MAIN_EXE_BASE_NAME,
        'MAIN_DLL_BASE_NAME_ANSI=\\"%s\\"' % _MAIN_DLL_BASE_NAME,
        'OFFICIAL_BUILD=%d' % win_env.Bit('build_server'),
        'TEST_CERTIFICATE=%d' % win_env.Bit('test_certificate'),
        'ONECLICK_PLUGIN_NAME=_T(\\"%s\\")' % (
            omaha_version_utils.GetONECLICK_PLUGIN_NAME()),
        'UPDATE_PLUGIN_NAME=_T(\\"%s\\")' % (
            omaha_version_utils.GetUPDATE_PLUGIN_NAME()),
        'CRASH_HANDLER_NAME=_T(\\"%s\\")' %
            omaha_version_utils.GetCRASH_HANDLER_NAME(),
        ],

    LIBS = [
        'advapi32',
        'comdlg32',
        'gdi32',
        'kernel32',
        'odbc32',
        'odbccp32',
        'ole32',
        'oleaut32',
        'shell32',
        'user32',
        'uuid',
        'winspool',
        ],

    LINKFLAGS = [
        '/nologo',
        '/SUBSYSTEM:WINDOWS,5.01',
        '/RELEASE',
        '/MAP',
        '/NODEFAULTLIB',
        '/DYNAMICBASE',   # Enable ASLR. See http://goo.gl/k2IE.
        '/NXCOMPAT',      # Enable NX support. See http://goo.gl/k2IE.
        '/SAFESEH',
        # '/VERBOSE:LIB', # Uncomment to get verbose link info for debugging.
        '/WX',            # Treat warnings as errors.
        ],

    # Defines in CCFLAGS are automatically included.
    RCFLAGS = [
        '/l 1033',  # /l == default language ID
        '/DBUILD_NUMBER=\\"%s\\"' % build_number,
        '/DOMAHA_COPYRIGHT_STRING_ENGLISH=\\"%s\\"' % (
            _OMAHA_COPYRIGHT_STRING_ENGLISH),
        ],
)

if _msc_ver >= omaha_version_utils.VC140:
  win_env.AppendUnique(
      CCFLAGS = [
          '/wd5026',  # move constructor was implicitly defined as deleted
                      # because a base class move constructor is inaccessible or
                      # deleted.
          '/wd5027',  # move move assignment operator was implicitly defined
                      # as deleted because a base class move assignment operator
                      # is inaccessible or deleted.
      ]
)

# VC2010 has a different way to record the location of the pdb file. The
# value of %PDB% is expanded to the name of the actual .pdb file without
# including any specific path information.
if _msc_ver >= omaha_version_utils.VC100:
  win_env.FilterOut(LINKFLAGS = ['/PDBPATH:none'])
  win_env.FilterOut(LINKFLAGS_OPTIMIZED = ['/PDBPATH:none'])
  win_env.AppendUnique(
     LINKFLAGS = [
        '/PDBALTPATH:%_PDB%'
     ],
  )

if _msc_ver >= omaha_version_utils.VC120 and not win_env.Bit('build_server'):
  win_env.AppendUnique(
      # Forces writes to the program database (PDB) file to allow otherwise,
      # for some reason, optimized builds fail when run with -j option.
      CCFLAGS = ['/FS', ]
  )

# Allow verification of these settings in the build log.
if win_env.Bit('build_server'):
  print 'OFFICIAL_BUILD=1'
  print 'TEST_CERTIFICATE=%d' % win_env.Bit('test_certificate')


# Add the parent directory of the main omaha directory to the Python path so
# that we can import using the format "omaha.subdir.module".
sys.path.append(os.path.split(win_env.Dir('$MAIN_DIR').abspath)[0])

# Make sure Vista SDK in all the important paths earlier in path than VC80.
for mid_dir in ['', 'vc']:
  for env_var, sub_dir in [('PATH', 'bin'),
                           ('INCLUDE', 'include'),
                           ('LIB', 'lib')]:
    var_path = os.path.join(_sdk_dir, mid_dir, sub_dir)
    if os.path.exists(var_path):
      win_env.PrependENVPath(env_var, var_path)

if not win_env.Bit('official_installers'):
  sys.path.append('tools')  # for import proxy_clsid_utils.py
  import proxy_clsid_utils

  # Generate uniqe proxy CLSIDs for each build.
  win_env.Execute('python "$MAIN_DIR\\tools\\proxy_clsid_utils.py"')
  win_env.Append(
      CPPDEFINES = [
        'PROXY_CLSID_IS_MACHINE=%s' % proxy_clsid_utils.GetMachineProxyClsid(),
        'PROXY_CLSID_IS_USER=%s' % proxy_clsid_utils.GetUserProxyClsid(),
      ],
  )

# WiX path has to be added before the WiX tool can be called.
win_env.AppendENVPath('PATH', os.environ['OMAHA_WIX_DIR'])

win_env.Tool('wix')

if win_env.Bit('suppress_light_validation'):
  win_env['WIXLIGHTFLAGS'].append('-sval')

_base_dirs = [
    '.',
    'base',
    'client',
    'common',
    'core',
    'crashhandler',
    'google_update',
    'goopdate',
    'net',
    'service',
    'setup',
    'statsreport',
    'third_party',
    'tools',
    'ui',
    ]

_normal_dirs = [
    'installers',
    'mi_exe_stub',
    'recovery',
    ]

_official_installers_dirs = [
    'installers',
    ]

_extra_dirs = [
    'enterprise',
    'standalone',
    ]

#
# Need to decide which subdirs need to be built.
#
_dirs_to_build_set = set()

if win_env.Bit('official_installers'):
  # Only want to build very specific subdirs.
  win_env.SetBits('no-tests')
  _dirs_to_build_set.update(_official_installers_dirs)
elif not win_env.Bit('bin'):
  # All other configs get the base dirs.
  _dirs_to_build_set.update(_base_dirs)

  if win_env.Bit('min'):
    print '*** Building Minimal Set of Projects ***'
  else:
    _dirs_to_build_set.update(_normal_dirs)

  if win_env.Bit('all'):
    _dirs_to_build_set.update(_extra_dirs)

# Build Google application-specific metainstallers.
if _is_google_update_build and \
   os.path.exists(win_env.Dir('$MAIN_DIR/internal').abspath):
      _dirs_to_build_set.update(['internal'])

_dirs_to_build = list(_dirs_to_build_set)

# This must be the last directory.
if not win_env.Bit('no-tests'):
  _dirs_to_build.append('testing')

# Instruct Hammer which dirs to build.
win_env['BUILD_SCONSCRIPTS'] = _dirs_to_build

# These are used by the Omaha Builder OmahaUnittest(). They must be added to the
# environment because there must be one per-mode.
win_env['all_in_one_unittest_sources'] = []
win_env['all_in_one_unittest_libs'] = set()

# Create the leaf debug Windows environment.
windows_debug_env = win_env.Clone(
    # Give this build a name and a description.
    BUILD_TYPE = 'dbg-win',
    BUILD_TYPE_DESCRIPTION = 'Windows debug build',
)

# Use common debug settings.
windows_debug_env.Tool('target_debug')

windows_debug_env.AppendUnique(
    CCFLAGS = [
        '/RTC1',
        '/Od',
        '/MTd',
        ],
    CPPDEFINES = [
        '_DEBUG',
        'DEBUG',
        ],
)

# Create the pure 64-bit debug Windows environment from the general one.
windows64_debug_env = windows_debug_env.Clone(
    # Give this build a name and a description.
    BUILD_TYPE = 'dbg-win64',
    BUILD_TYPE_DESCRIPTION = 'Windows 64 bit debug build',
)
windows64_debug_env.ConfigureEnvFor64Bit()

# Create the leaf optimized Windows environment.
windows_optimized_env = win_env.Clone(
    # Give this build a name and a description.
    BUILD_TYPE = 'opt-win',
    BUILD_TYPE_DESCRIPTION = 'Windows optimized build',
)

# Use common optimized settings.
windows_optimized_env.Tool('target_optimized')

windows_optimized_env.AppendUnique(
    CCFLAGS = [
        '/O1',        # Optimize for small size.
        '/Oy-',       # Disable frame pointer omission.
        '/GL',        # Global optimization goes with link flag '/LTCG'
        '/MT',        # Use the multithread,
                      # static version of the run-time library.
        ],
    CPPDEFINES = [
        'NDEBUG',
        'SHIPPING'    # code in 'common' needs this
        ],
    ARFLAGS = [
        '/LTCG',      # Set LTCG for creation of .lib files too.
        ],
    LINKFLAGS = [
        '/INCREMENTAL:NO', # Disable incremental linking.
        '/OPT:REF',   # Eliminates functions and data that are never referenced.
        '/OPT:ICF=32',# Perform identical COMDAT folding (32 iterations).
        '/LTCG',      # Link-time code generation goes with cl flag '/GL'.
        ],
)

# Create the all-64-bit optimized Windows environment from the general one.
windows64_optimized_env = windows_optimized_env.Clone(
    # Give this build a name and a description.
    BUILD_TYPE = 'opt-win64',
    BUILD_TYPE_DESCRIPTION = 'Windows 64 bit optimized build',
)
windows64_optimized_env.ConfigureEnvFor64Bit()

# Create an environment for coverage test builds, based on the dbg build.
windows_coverage_env = windows_debug_env.Clone(
    BUILD_TYPE = 'coverage-win',
    BUILD_TYPE_DESCRIPTION = 'Windows coverage build',
)
# The Coverage build require additional tools that not everyone has. Therefore,
# it should build as part of the all group.
windows_coverage_env.FilterOut(BUILD_GROUPS=['all'])

windows_coverage_env.Tool('code_coverage')

# Coverage will run omaha_unittest.exe, which requires some extra environment.
for env_var in os.environ:
  if not env_var in windows_coverage_env['ENV']:
    windows_coverage_env['ENV'][env_var] = os.environ[env_var]

# Create a target that covers everything in the staging dir, as many of those
# files will be required for the unittests to run successfully.
# TODO(omaha3): This may not be necessary when using ComponentTestProgram. If it
# is, it needs to be changed to use test/ instead of $STAGING_DIR/.
windows_coverage_env.Alias(
    'run_omaha_unittest_for_coverage',
    '$STAGING_DIR',
    '$STAGING_DIR/omaha_unittest.exe'
)
windows_coverage_env.Append(
    # TODO(omaha): We cannot run our unit tests on the new build system. Ensure
    # coverage works with the new test execution system.
    # COVERAGE_TARGETS=['run_omaha_unittest_for_coverage'],
    COVERAGE_INSTRUMENTATION_PATHS=['$STAGING_DIR'],
    # This value should only be used in code if absolutely necessary.
    CPPDEFINES=['COVERAGE_ENABLED'],
)

# TODO(omaha): Prevent the analyzer, which will fail, from running until we can
# run unit tests on the build system. See the TODO above.
windows_coverage_env['COVERAGE_START_CMD'] = '@echo Not starting coverage'
windows_coverage_env['COVERAGE_STOP_CMD'] = '@echo Not ending coverage'

# Skip signing in coverage build until the last step.
windows_coverage_env['SIGNTOOL_ORIG'] = windows_coverage_env['SIGNTOOL']
windows_coverage_env['SIGNTOOL'] = '@echo Signing deferred: '

def SigningCommand(env, filename):
  # Only do signing if there is a certificate file or certificate name.
  if env.subst('$CERTIFICATE_PATH') or env.subst('$CERTIFICATE_NAME') \
      or env.subst('$CERTIFICATE_HASH'):
    # The command used to do signing (target added on below).
    signing_cmd = '$SIGNTOOL_ORIG sign '
    # Add in certificate file if any.
    if env.subst('$CERTIFICATE_PATH'):
      signing_cmd += ' /f "$CERTIFICATE_PATH"'
      # Add certificate password if any.
      if env.subst('$CERTIFICATE_PASSWORD'):
        signing_cmd += ' /p "$CERTIFICATE_PASSWORD"'
    # Add certificate store if any.
    if env.subst('$CERTIFICATE_NAME'):
      # The command used to do signing (target added on below).
      signing_cmd += ' /s "$CERTIFICATE_STORE" /n "$CERTIFICATE_NAME"'
    # Add cert hash if any.
    if env.subst('$CERTIFICATE_HASH'):
      signing_cmd += ' /sha1 "$CERTIFICATE_HASH"'
    if env.Bit('use_authenticode_machine_store'):
      signing_cmd += ' /sm'
    # Add timestamp server if any.
    if env.subst('$TIMESTAMP_SERVER'):
      signing_cmd += ' /t "$TIMESTAMP_SERVER"'
    # Add in target name
    signing_cmd += ' "%s"' % filename
    return signing_cmd
  else:
    return 'echo no signing needed'

def _IsInstrumentableFileType(file):
  if (file.endswith('.exe') or
      file.endswith('.dll')):
    return True
  return False

def _IsSignableFileType(file):
  if (file.endswith('.exe') or
      file.endswith('.dll') or
      file.endswith('.msi') or
      file.endswith('.msp')):
    return True
  return False

# Sign files during the install stage, since instrumentation invalidates the
# signature. Signing within the individual build files was disabled above.
# Do not sign intermediate "_unsigned" or "_unittest" files.
# Instrumented files must be signed after installing becuase install is what
# does the instrumentation. This also seems to be required to avoid
# unnecessarily rebuilding non-instrumentable files.
def _PostCoverageSigningInstall(dest, source, env):
  if _IsInstrumentableFileType(dest) or not _IsSignableFileType(dest):
    # Install the file to staging. Includes instrumentation if appropriate.
    env['PRECOVERAGE_SIGN_INSTALL'](dest, source, env)
  else:
    # For signable but not instrumentable files, copy the files rather than
    # using PRECOVERAGE_SIGN_INSTALL as this works around unnecessary rebuilds
    # caused by http://code.google.com/p/swtoolkit/issues/detail?id=13.
    env.Execute('copy "%s" "%s"' % (source, dest))

  if (_IsSignableFileType(dest) and
      (-1 == dest.find('_unsigned')) and
      (-1 == dest.find('_unittest')) and
      os.path.split(os.path.split(dest)[0])[1] == 'staging'):
    env.Execute(SigningCommand(env, dest))

windows_coverage_env['PRECOVERAGE_SIGN_INSTALL'] = (
    windows_coverage_env['INSTALL'])
windows_coverage_env['INSTALL'] = _PostCoverageSigningInstall


# Make debug the default build after any copies of it have been made.
windows_debug_env.Append(BUILD_GROUPS = ['default'])
windows64_debug_env.Append(BUILD_GROUPS = ['default'])

# ----------------------------------------------------------

# Build the variants listed above.
# This step will call each of the SConscripts (build.scons) listed,
# once for each variant currently being built.
if GetOption('x64'):
  print 'Using 64 bit environments.'
  _environments = [
      windows64_debug_env,
      windows64_optimized_env,
      ]
else:
  _environments = [
      windows_debug_env,
      windows_optimized_env,
      windows_coverage_env,
      ]

BuildEnvironments(_environments)

if 'HAMMER_RUNS_TESTS' in os.environ.keys():
  # Hammer sets the default target to 'scons-out'. This causes run_* aliases
  # to also be built, which means the tests run by default. To avoid this, clear
  # Default and set the default to just build the programs.
  Default(None)
  # TODO(omaha): Not all of our core binaries are included in these three
  # aliases. This is because SignedBinary() and Command() do not add the outputs
  # to a group. Fix this.
  Default(['all_programs', 'all_libraries', 'all_test_programs'])

if win_env.Bit('msvs'):
  source_project = win_env.ComponentVSDirProject('all_source', ['$MAIN_DIR'])

  # 'all_*' values do not appear to be populated until after BuildEnvironments
  # is called. Thus, the solution will be specific to either debug or optimized.
  # ComponentVSSourceProject() might be more desirable, but it does not appear
  # to work.
  windows_debug_env.ComponentVSSolution('omaha_dbg',
                                        ['all_programs', 'all_libraries'],
                                        projects=[source_project])
